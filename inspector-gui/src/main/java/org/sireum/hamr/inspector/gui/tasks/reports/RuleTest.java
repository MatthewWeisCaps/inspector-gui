package org.sireum.hamr.inspector.gui.tasks.reports;

import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.extern.slf4j.Slf4j;
import org.junit.jupiter.api.DynamicTest;
import org.junit.jupiter.api.TestFactory;
import org.junit.jupiter.api.extension.ExtendWith;
import org.junit.platform.runner.JUnitPlatform;
import org.junit.runner.RunWith;
import org.sireum.hamr.inspector.common.ArtUtils;
import org.sireum.hamr.inspector.common.Msg;
import org.sireum.hamr.inspector.services.MsgService;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

import java.util.Collection;
import java.util.List;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicReference;
import java.util.stream.Collectors;

// generated by junit5 then post-processed by RuleExtensionPostProcessor
@Slf4j
@RunWith(JUnitPlatform.class)
@NoArgsConstructor @SuppressWarnings({"SpringJavaAutowiredFieldsWarningInspection", "RedundantSuppression"}) // <-- protection for generated classes
class RuleTest {

    @Getter @Setter
    private MsgService msgService = null;

    @Getter @Setter
    private ArtUtils artUtils = null;

    @Getter @Setter
    private List<RuleTestJob> jobs;

    /**
     * CANNOT BE private OR static!
     * MUST BE NAMED "dynamicTestFactory" (this string is used above for reflection)
     * see: https://junit.org/junit5/docs/current/user-guide/#writing-tests-dynamic-tests
     *
     * @return
     */
    @TestFactory
    @ExtendWith(RuleExtensionPostProcessor.class)
    Collection<DynamicTest> dynamicTestFactory() {
        return jobs.stream().sequential()
                .map(job -> DynamicTest.dynamicTest(job.getName(), () -> {
                    final var error = new AtomicBoolean();
                    final var errorCause = new AtomicReference<Throwable>();
                    final var success = new AtomicBoolean();

                    final var key = job.getSession();
                    final var rule = job.rule;

                    // todo replace count and live-subscribe with replaySnapshop() method
                    final Mono<Long> msgCount = msgService.count(key);
                    final org.sireum.hamr.inspector.stream.Flux<Msg> input = org.sireum.hamr.inspector.stream.Flux.from(msgCount.flatMapMany(count -> msgService.replayThenLive(key).take(count)));
                    final Flux<?> output = Flux.from(rule.rule(input, artUtils));

                    output
                            .onErrorStop()
                            .doOnError(throwable -> {
                                error.set(true);
                                errorCause.set(throwable);
                            })
                            .doOnComplete(() -> success.set(true))
                            .then()
                            .block();

                    final boolean e = error.get();
                    final boolean s = success.get();

                    if (!e && s) {
                        log.info("Test of Rule {} has completed successfully.", rule.name());
                    } else if (e && !s) {
                        final Throwable ec = errorCause.get();
                        log.info("Test of Rule {} has ended in an error: {}", rule.name(), ec);
                        throw ec;
                    } else if (e && s) {
                        final String cause = "a Rule should not be capable of both completing and erroring out";
                        final Throwable ec = errorCause.get();
                        log.error(cause, ec);
                        throw new IllegalStateException(cause, ec);
                    } else {
                        final String cause = "a Rule should not end without indicating error or success";
                        log.error(cause);
                        throw new IllegalStateException(cause);
                    }
                })).collect(Collectors.toUnmodifiableList());
    }
}
